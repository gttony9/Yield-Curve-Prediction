x``---
title: "Kalman_filter"
output: html_document
date: "2025-02-18"
---

```{r}
library(tibble)
library(MASS)
``` 


```{r}
# This  funciton is used for one step ahed prediction
# The dimension of State Space Paramters are generalized

FK_prediction <- function(A, B, C, D, R, Q, last_x, last_x_var){
  # A: state transition matrix for latent paramters x (a * a)
  # B: process noise coefficient matrix (a * q)
  # Q: process noise covariance matrix (q) 
  
  # C: observation matrix (k * a )
  # D: time-varying measurement noise coefficient matrix (k * r)
  # R: measurement noise covariance matrix (r * r)
  
  # last_x: x_{t-1|t-1}, the expectation of latent paramter in the last state
  # last_x_var: Sigma_{t-1|t-1}, the covariance matrix in the last state
  
  E_x_t <- A %*% last_x  # x_{t|t-1} one step ahead prediction for latent paramter
  Var_x_t <- A %*% last_x_var %*% t(A)  + B %*% Q  %*%  B # Sigma_{t|t-1} covariance matrix of one step ahead prediction for latent paramter
  
  E_y_t <- C %*% A %*% last_x # y_{t|t-1} one step ahead prediction for reponse variable
  Var_y_t <- C %*% (A %*% last_x_var %*% t(A) + B %*% Q %*% t(B)) %*% t(A) %*% t(C) + D %*% R %*% t(D) # F, covariance for y prediction
  
  
  return(list(
    E_x_t = E_x_t,
    Var_x_t = Var_x_t,
    E_y_t = E_y_t,
    Var_y_t = Var_y_t
  ))
}
```


# Kalman Filter Paramter Estimation
```{r}
KF_Estimate <- function(y_data , T_, dim_A = a, dim_cov_Q = q, dim_cov_R = r){
    # y_data: Parameter of the form of a list of data frames 
    # T_: length of time window
    # x: a * 1
    # y: k * 1
    k <- ncol(y) # dimension of y at time t
    
    # Initialization of parameters 
    A <- diag(a) # a * a
    B <- matrix(0, nrow = a, ncol = q)  # a * q  
    Q <- diag(q) # q * q
    C <- matrix(0, nrow = k, ncol = a) # k * a
    D <- matrix(0, nrow = k, ncol = r) # k * r
    R <- diag(r) # r * r
    
    # index of each paramters in theta
    A_index <- 1: (a^2)
    B_index <- (tail(A_index, 1)+1): (tail(A_index, 1)+a*q)
    Q_index <- (tail(B_index, 1)+1): (tail(B_index, 1)+q*q)
    C_index <- (tail(Q_index, 1)+1): (tail(Q_index, 1)+k*a)
    D_index <- (tail(C_index, 1)+1): (tail(C_index, 1)+k*r)
    R_index <- (tail(D_index, 1)+1): (tail(D_index, 1)+r*r)
    
    # vectorize all entries of parameters to a vector
    theta <- c(as.vector(A), as.vector(B), as.vector(Q), as.vector(C), as.vector(D), as.vector(R))
    
    # place holder for last result iteration of parameter estimation
    last_theta <- 10 * c(as.vector(A), as.vector(B), as.vector(C), as.vector(D), as.vector(R), as.vector(Q)) 
    
    # Initialization of partial derivatives w.r.t parameters
    partial_log_l_theta <- rep(0, length(theta))
    
    num_run <- 0
    
    
    repeat{
        # Initialize x and Sigma
        last_x <- matrix( 1, ncol =1, nrow = a) # x_{0|0}
        last_Sig <- diag(a) #Sigma_{0|0}
        
        # Initialization of partial derivatives at time 0|0
        # expand the matrix partial derivative into a vector with a length equal to the number of its entries.
        last_partial_x_theta <- array(matrix(1, nrow = a, ncol = 1), dim = c(a, 1, length(theta))) # length(theta) *(a * 1)
        last_partial_Sig_theta <- array(matrix(1, nrow = a, ncol = a), dim = c(a, 1, length(theta))) # length(theta) *(a * a)
        
        # list of y_data rate data (T_ * (N * 2))
        y_t <- t(y_data)

        # iterate along time 1:T_
        for(i in 1:ncol(y_t)){  
          
            pred_res <- FK_prediction(A, B, C, D, R, Q, last_x, last_Sig) # one step ahead prediction of x and y
            
            cur_x <- pred_res$E_x_t
            cur_Sig <- pred_res$Var_x_t
            cur_y <- pred_res$E_y_t
            F_t <- pred_res$Var_y_t
            
            K_t <- cur_Sig %*% t(C) %*% ginv(F_t) # Kalman Gain a * k
            e_t <- y_t[,i] - C %*% cur_x # innovation k * 1
            
            # state estimate update
            next_x <- cur_x + K_t %*% (y_t[,i] - C %*% cur_x) # x_{t|t}
            next_Sig <- cur_Sig - K_t %*% C %*% cur_Sig # Sigma_{t|t}
                
            # calculate the partial derivatives w.r.t. each paramter
            partial_A_res <- get_partial_A(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_theta[A_index], last_partial_Sig_theta[A_index], F_t, e_t, A, B, C, D, Q, R)
            partial_B_res <- get_partial_B(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_theta[B_index], last_partial_Sig_theta[B_index], F_t, e_t, A, B, C, D, Q, R)
            partial_Q_res <- get_partial_Q(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_theta[Q_index], last_partial_Sig_theta[Q_index], F_t, e_t, A, B, C, D, Q, R)
            partial_C_res <- get_partial_C(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_theta[C_index], last_partial_Sig_theta[C_index], F_t, e_t, A, B, C, D, Q, R)
            partial_D_res <- get_partial_D(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_theta[D_index], last_partial_Sig_theta[D_index], F_t, e_t, A, B, C, D, Q, R)
            partial_R_res <- get_partial_R(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_theta[R_index], last_partial_Sig_theta[R_index], F_t, e_t, A, B, C, D, Q, R)
            
            # convert the partial derivative from entry by entry form into matrix form
            partial_log_l_t <- c(partial_A_res$log_likelihood_A, partial_B_res$log_likelihood_B, partial_Q_res$log_likelihood_Q, partial_C_res$log_likelihood_C, partial_D_res$log_likelihood_D, partial_R_res$log_likelihood_R)
            
            partial_log_l_theta <- partial_log_l_theta + partial_log_l_t
          
            # update for the next state ( in the format of linked list)
            last_partial_x_theta <- c(partial_A_res$next_partial_x_A, partial_B_res$next_partial_x_B, partial_Q_res$next_partial_x_Q, partial_C_res$next_partial_x_C, partial_D_res$next_partial_x_D, partial_R_res$next_partial_x_R)
            
            last_partial_Sig_theta <- c(partial_A_res$next_partial_Sig_A, partial_B_res$next_partial_Sig_B, partial_Q_res$next_partial_Sig_Q, partial_C_res$next_partial_Sig_C, partial_D_res$next_partial_Sig_D, partial_R_res$next_partial_Sig_R)
            
            last_x <- next_x # x_{t|t}
            last_Sig <- next_Sig  # Sigma_{t|t}
            
        }
  
        # update the paramter by gradient descent
        theta <- theta + 0.000001 * partial_log_l_theta
        
        # Compute the convergece condition by the ratio of difference of parameters, using Euclidean norm
        ratio <- sum(theta - last_theta)/sum(theta)
        
        if(ratio < 0.0001){
          break
        }
        
        last_theta <- theta

    }
    
    A <- matrix(theta(A_index), nrow = a, ncol = q)
    B <- matrix(theta(B_index), nrow = a, ncol = q) 
    Q <- matrix(theta(C_index), nrow = q, ncol = q)
    C <- matrix(theta(D_index), nrow = k, ncol = a)
    D <- matrix(theta(E_index), nrow = k, ncol = r)
    R <- matrix(theta(F_index), nrow = r, ncol = r)
    
    return(list(A = A, B = B, C = C, D = D, R = R, Q = Q))
  
}

```





