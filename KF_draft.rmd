---
title: "All Functions"
format: pdf
---
```{r}
library(tibble)
library(MASS)
``` 


```{r}
#This  funciton is used for one step ahed prediction

FK_prediction <- function(A, B, C, D, R, Q, last_x, last_x_var){
  # A: state transition matrix for latent paramters x (3 * 3)
  # B: process noise coefficient matrix (3 * m ;  default: 3 * 3 diagonal)
  # C: observation matrix (N * 3 where N is the number of tenors in a day)
  # D: time-varying measurement noise coefficient matrix (N * k;  detaul: N * N, where N is the number of tenors in a day)
  # Q: process noise covariance matrix (m * m ; default: 3 * 3 ) 
  # R: measurement noise covariance matrix (k * k, dedault N * N)
  # last_x: x_{t-1|t-1}, the expectation of latent paramter in the last state
  # last_x_var: Sigma_{t-1|t-1}, the covariance matrix in the last state
  
  E_x_t <- A %*% last_x  # x_{t|t-1} one step ahead prediction for latent paramter
  Var_x_t <- A %*% last_x_var %*% t(A)  + B %*% Q  %*%  B # Sigma_{t|t-1} covariance matrix of one step ahead prediction for latent paramter
  
  E_y_t <- C %*% A %*% last_x # y_{t|t-1} one step ahead prediction for reponse variable
  Var_y_t <- C %*% (A %*% last_x_var %*% t(A) + B %*% Q %*% t(B)) %*% t(A) %*% t(C) + D %*% R %*% t(D) # F, covariance for y prediction
  
  
  return(list(
    E_x_t = E_x_t,
    Var_x_t = Var_x_t,
    E_y_t = E_y_t,
    Var_y_t = Var_y_t
  ))
}
```

```{r}
get_C <- function(lambda, tenors = c(1/12,3/12,6/12,1,2,3,5,7,10,20)) {

  
  # Compute basis functions
  B0 <- rep(1, length(tenors))
  B1 <- (1 - exp(-lambda * tenors)) / (lambda * tenors)
  B2 <- B1 - exp(-lambda * tenors)
  C_matrix <- cbind(B0, B1, B2)
  
  return(C_matrix)
}

T_ <- 960 

```


# Kalman Filter Paramter Estimation
```{r}
KF_Estimate <- function(yields, T_, tenors = c(1/12,3/12,6/12,1,2,3,5,7,10,20), lambda = 0.5){
    # yield: Parameter of the form of a list of data frames containing ZCB spot rate
    # T_: length of time window
    # tenors: list of time to maturities
    # lambda_list: grid of lambda
  
    N <- length(tenors) # numerb of tenors
    
    # Initialization of parameters 
    # In the early stage, we assume default dimension for Q and R, B hence D to be 3*3/n*n identity matrix 
    A <- diag(3) # 3 * 3
    B <- diag(3) # 3 * 3
    C <- get_C(lambda, tenors = tenors) #  nelson siegel design matrix
    D <- diag(N) # N * N
    Q <- diag(3) # 3 * 3
    R <- diag(N) # N * N
    
     # place holder for last result iteration of parameter estimation
    lastA <- 10*diag(3)  
    lastQ <- 10*diag(3)
    lastR <- 10*diag(N) 
    
    # Initialization of partial derivatives w.r.t paramters
    partial_log_l_A <- diag(3)
    partial_log_l_Q <- diag(3)
    partial_log_l_R <- diag(N)
    num_run <- 0
    repeat{
        # Initilaiation of paramters
        
        last_x <- matrix( 1, ncol =1, nrow = 3) # x_{0|0}
        last_Sig <- diag(3) #Sigma_{0|0}
        
        # Initilization of partial derivatives at time 0|0
        # expand the matrix partial derivative into a vector with a length equal to the number of its entries.
        last_partial_x_A <-  lapply(1:9, function(x) matrix(1, nrow = 3, ncol = 1)) # 9 * (1 * 3) 
        last_partial_Sig_A <-  lapply(1:9, function(x) diag(3)) # 9 * (3 * 3)
        
        last_partial_x_Q <-  lapply(1:9, function(x) matrix(1, nrow = 3, ncol = 1)) # 9 * (1 * 3)
        last_partial_Sig_Q <-  lapply(1:9, function(x) diag(3)) # 9 * (3 * 3)
        
        last_partial_x_R <-  lapply(1:(N*N), function(x) matrix(1, nrow = 3, ncol = 1)) # N^2 * (1 * 3)
        last_partial_Sig_R <-  lapply(1:(N*N), function(x) diag(3)) # N^2 * (3 * 3)
        
        # list of yield rate data (T_ * (N * 2))
        y_t <- vector("list", T_)  
        for (t in 1:T_) {
          y_t[[t]] <- as.matrix(yields[[t]][2])  
        }

        # iterate along time 1:T_
        for(i in 1:length(yields)){  
          
            pred_res <- FK_prediction(A, B, C, D, R, Q, last_x, last_Sig) # one step ahead prediction of x and y
            
            cur_x      <- pred_res$E_x_t
            cur_Sig  <- pred_res$Var_x_t
            cur_y           <- pred_res$E_y_t
            F_t         <- pred_res$Var_y_t
            
            K_t <- cur_Sig %*% t(C) %*% ginv(F_t) # Kalman Gain 3 * n
            e_t <- y_t[[i]] - C %*% cur_x # innovation N * 1
            
            # state estimate update
            next_x <- cur_x + K_t %*% (y_t[[i]] - C %*% cur_x) # x_{t|t}
            next_Sig <- cur_Sig - K_t %*% C %*% cur_Sig # Sigma_{t|t}
                
            # calcualte the partial derivatives w.r.t. each paramter
            partial_A_res <- get_partial_A(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_A, last_partial_Sig_A, F_t, e_t, A, B, C, D, Q, R)
            partial_Q_res <- get_partial_Q(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_Q, last_partial_Sig_Q, F_t, e_t, A, B, C, D, Q, R)
            partial_R_res <- get_partial_R(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_R, last_partial_Sig_R, F_t, e_t, A, B, C, D, Q, R)
            
            # conver the partial derivative from entry by entry form into matrix form
            partial_log_A_t <- matrix(partial_A_res$log_likelihood_A, nrow = 3, ncol = 3, byrow = TRUE)  
            partial_log_Q_t <- matrix(partial_Q_res$log_likelihood_Q, nrow = 3, ncol = 3, byrow = TRUE) 
            partial_log_R_t <- matrix(partial_R_res$log_likelihood_R, nrow = N, ncol = N, byrow = TRUE) 

            
            # add the current time partial_log_likelihood to the summation of partial_log_likelihood over time 1:T_
            partial_log_l_A <- partial_log_l_A + partial_log_A_t
            partial_log_l_Q <- partial_log_l_Q + partial_log_Q_t
            partial_log_l_R <- partial_log_l_R + partial_log_R_t
          
            # update for the next state ( in the format of linked list)
            last_partial_x_A <- partial_A_res$next_partial_x_A
            last_partial_Sig_A <- partial_A_res$next_partial_Sig_A
            
            last_partial_x_Q <- partial_Q_res$next_partial_x_Q
            last_partial_Sig_Q <- partial_Q_res$next_partial_Sig_Q
            
            last_partial_x_R <- partial_R_res$next_partial_x_R
            last_partial_Sig_R <- partial_R_res$next_partial_Sig_R
            
            last_x <- next_x # x_{t|t}
            last_Sig <- next_Sig  # Sigma_{t|t}
            
        
        }
  
        # update the 
        A <- A - 0.000001 * partial_log_l_A
        Q <- Q - 0.000001 * partial_log_l_Q
        R <- R - 0.000001 * partial_log_l_R
        
        # Compute the convergece condition by the ratio of difference of paramters, using Euclidean norm
        num <- norm(A - lastA, type = "F") + norm(Q - lastQ, type = "F") + norm(R - lastR, type = "F") # 
        denom <- norm(A, type = "F") + norm(Q, type = "F") + norm(R, type = "F")
        ratio <- num/denom
        #print(ratio)
        
        if(ratio < 0.0001){
          break
        }
        print(F_t)
        # parameter update for the next iteration
        lastA <- A
        lastQ <- Q
        lastR <- R
      

        
        
    }
      
    return(list(A = A, B = B, C = C, D = D, R = R, Q = Q))
  
    
  
    
}

```


# Partial Derivatives
```{r}
# All three get_partial() functions follows the same notation
# The steps strictly follows the partial derivative mathematics in appendex
get_partial_A <- function(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_A, last_partial_Sig_A, F_t, e_t, A, B, C, D, Q, R) {
  
  # last: {t-1|t-1}
  # cur:  {t|t-1}
  # cur:  {t|t}
  
  # Initialize matrices to store results
  cur_partial_x_A <- list() # 3 * 1 matrix for each i,j entry
  cur_partial_Sig_A <- list() # 3 * 3 matrix for each i,j entry
  
  next_partial_x_A <- list() # 3 * 1 matrix for each i,j entry
  next_partial_Sig_A <- list() # 3 * 3 matrix for each i,j entry
  
  partial_e_A <- list() # N * 1 matrix at time t
  partial_F_A <- list() # N * N matrix at time t
  
  log_likelihood <- vector() # partial log likelihood for each i,j
  
  count <- 1 # index of iterate the matrix in vec() form
  
  for (i in 1:3) {
    for (j in 1:3) {
      
      # Initialize canonical basis matrix matrices J and J_t
      J <- matrix(0, nrow = 3, ncol = 3)
      J[i, j] <- 1
      
      J_t <- matrix(0, nrow = 3, ncol = 3)
      J_t[j, i] <- 1
      
      
      cur_partial_x_A[[count]] <- J %*% last_x + A %*% last_partial_x_A[[count]] # (1)
      cur_partial_Sig_A[[count]] <- J %*% last_Sig %*% A + A %*% last_partial_Sig_A[[count]] %*% t(A) + A %*% last_Sig %*% J_t # (2)

      partial_e_A[[count]] <-  -C %*% J %*% last_x - C %*% A %*% last_partial_x_A[[count]] # (3)
      partial_F_A[[count]] <-  C %*% cur_partial_Sig_A[[count]] %*% t(C) # (4)
      
      
      next_partial_x_A[[count]] <-  cur_partial_x_A[[count]] + cur_partial_Sig_A[[count]] %*% t(C) %*% ginv(F_t) %*% e_t -
        cur_Sig %*% t(C) %*% ginv(F_t) %*% partial_F_A[[count]] %*% ginv(F_t) %*% e_t +
        cur_Sig %*% t(C) %*% ginv(F_t) %*% partial_e_A[[count]]  # (5)

      next_partial_Sig_A[[count]] <-  cur_partial_Sig_A[[count]] -
        cur_partial_Sig_A[[count]] %*% t(C) %*% ginv(F_t) %*% C %*% cur_Sig +
        cur_Sig %*% t(C) %*% ginv(F_t) %*% partial_F_A[[count]] %*% ginv(F_t) %*% C %*% cur_Sig -
        cur_Sig %*% t(C) %*% ginv(F_t) %*% C %*% cur_partial_Sig_A[[count]] # (6)
    
      # compute the partial log likelihood matrix
      trace_term_A <- sum(diag(ginv(F_t) %*% partial_F_A[[count]]))
      term1_A <- t(partial_e_A[[count]]) %*% F_t %*% e_t
      term2_A <- t(e_t) %*% ginv(F_t) %*% partial_F_A[[count]]  %*% ginv(F_t) %*% e_t
      term3_A <- t(e_t) %*% F_t %*% partial_e_A[[count]]
      log_likelihood[count] <-  - 0.5 * trace_term_A - 0.5 * (term1_A + term2_A + term3_A)
      
      count <- count +1 # update index
    }
  }
  
  # Return results
  return(list(
    next_partial_x_A = next_partial_x_A,
    next_partial_Sig_A = next_partial_Sig_A,
    cur_partial_x_A = cur_partial_x_A,
    cur_partial_Sig_A = cur_partial_Sig_A,
    partial_e_A = partial_e_A,
    partial_F_A = partial_F_A,
    log_likelihood_A = log_likelihood
  ))
}





get_partial_Q <- function(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_Q, last_partial_Sig_Q, F_t, e_t, A, B, C, D, Q, R) {

  # Initialize matrices to store results
  cur_partial_x_Q <- list()
  cur_partial_Sig_Q <- list()
  partial_e_Q <- list()
  partial_F_Q <- list()
  next_partial_x_Q <- list()
  next_partial_Sig_Q <- list()

  log_likelihood <- vector()
  count <- 1
  
  for (i in 1:nrow(Q)) {
    for (j in 1:ncol(Q)) {
      
      # Initialize elementary matrix J_Q
      J_Q <- matrix(0, nrow = 3, ncol = 3)
      J_Q[i, j] <- 1  # Set (i,j) entry to 1

      cur_partial_x_Q[[count]] <- A %*% last_partial_x_Q[[count]]
      cur_partial_Sig_Q[[count]] <- A %*% last_partial_Sig_Q[[count]] %*% t(A) + B %*% J_Q %*% t(B)

      partial_e_Q[[count]] <-  -C %*% A %*% last_partial_x_Q[[count]]
      partial_F_Q[[count]] <- C %*% cur_partial_Sig_Q[[count]] %*% t(C)

      next_partial_x_Q[[count]] <- cur_partial_x_Q[[count]] + cur_partial_Sig_Q[[count]] %*% t(C) %*% ginv(F_t) %*% e_t -
        cur_Sig %*% t(C) %*% ginv(F_t) %*% partial_F_Q[[count]] %*% ginv(F_t) %*% e_t +
        cur_Sig %*% t(C) %*% ginv(F_t) %*% partial_e_Q[[count]]

      next_partial_Sig_Q[[count]] <-  cur_partial_Sig_Q[[count]] -
        cur_partial_Sig_Q[[count]] %*% t(C) %*% ginv(F_t) %*% C %*% cur_Sig +
        cur_Sig %*% t(C) %*% ginv(F_t) %*% partial_F_Q[[count]] %*% ginv(F_t) %*% C %*% cur_Sig -
        cur_Sig %*% t(C) %*% ginv(F_t) %*% C %*% cur_partial_Sig_Q[[count]]
      
      
      trace_term_Q <- sum(diag(ginv(F_t) %*% partial_F_Q[[count]]))
      term1_Q <- t(partial_e_Q[[count]]) %*% F_t %*% e_t
      term2_Q <- t(e_t) %*% ginv(F_t) %*% partial_F_Q[[count]] %*% ginv(F_t) %*% e_t
      term3_Q <- t(e_t) %*% F_t %*% partial_e_Q[[count]]
      
      log_likelihood[count] <-  - 0.5 * trace_term_Q - 0.5 * (term1_Q + term2_Q + term3_Q)
      count <- count +1
    }
  }
  
  # Return results as a list
  return(list(
    next_partial_x_Q = next_partial_x_Q,
    next_partial_Sig_Q = next_partial_Sig_Q,
    cur_partial_x_Q = cur_partial_x_Q,
    cur_partial_Sig_Q = cur_partial_Sig_Q,
    partial_e_Q = partial_e_Q,
    partial_F_Q = partial_F_Q,
    log_likelihood_Q = log_likelihood
  ))
}





get_partial_R <- function(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_R, last_partial_Sig_R, F_t, e_t, A, B, C, D, Q, R) {
  
  # Get the dimension of R

  # Initialize matrices to store results
  cur_partial_x_R <- list()
  cur_partial_Sig_R <- list()
  
  partial_e_R <- list()
  partial_F_R <- list()
  
  next_partial_x_R <- list()
  next_partial_Sig_R <- list()
  
  N <- nrow(R)
  
  log_likelihood <- vector()
  count <- 1
  
  for (i in 1:N) {
    for (j in 1:N) {
      
      # Initialize elementary matrix J_R
      J_R <- matrix(0, nrow = N, ncol = N)
      J_R[i, j] <- 1  # Set (i,j) entry to 1
      
      cur_partial_x_R[[count]] <- A %*% last_partial_x_R[[count]]
      
      cur_partial_Sig_R[[count]] <- A %*% last_partial_Sig_R[[count]] %*% t(A) 
      
      partial_e_R[[count]] <-  -C %*% A %*% last_partial_x_R[[count]]
      
      partial_F_R[[count]] <- C %*% cur_partial_Sig_R[[count]] %*% t(C) + D %*% J_R %*% t(D)

      next_partial_x_R[[count]] <- cur_partial_x_R[[count]] + cur_partial_Sig_R[[count]] %*% t(C) %*% ginv(F_t) %*% e_t -
        cur_Sig %*% t(C) %*% ginv(F_t) %*% partial_F_R[[count]] %*% ginv(F_t) %*% e_t +
        cur_Sig %*% t(C) %*% ginv(F_t) %*% partial_e_R[[count]]

      next_partial_Sig_R[[count]] <- cur_partial_Sig_R[[count]] -
        cur_partial_Sig_R[[count]] %*% t(C) %*% ginv(F_t) %*% C %*% cur_Sig +
        cur_Sig %*% t(C) %*% ginv(F_t) %*% partial_F_R[[count]] %*% ginv(F_t) %*% C %*% cur_Sig -
        cur_Sig %*% t(C) %*% ginv(F_t) %*% C %*% cur_partial_Sig_R[[count]]
      
      
      trace_term_R <- sum(diag(ginv(F_t) %*% partial_F_R[[count]]))
      term1_R <- t(partial_e_R[[count]]) %*% F_t %*% e_t
      term2_R <- t(e_t) %*% ginv(F_t) %*% partial_F_R[[count]] %*% ginv(F_t) %*% e_t
      term3_R <- t(e_t) %*% F_t %*% partial_e_R[[count]]
      
      log_likelihood[count] <-  - 0.5 * trace_term_R - 0.5 * (term1_R + term2_R + term3_R)
      count <- count +1
    }
  }
  
  # Return results as a list
  return(list(
    next_partial_x_R = next_partial_x_R,
    next_partial_Sig_R = next_partial_Sig_R,
    cur_partial_x_R = cur_partial_x_R,
    cur_partial_Sig_R = cur_partial_Sig_R,
    partial_e_R = partial_e_R,
    partial_F_R = partial_F_R,
    log_likelihood_R = log_likelihood
  ))
}


```

```{r}

KF_likelihood <-function(A, B, C, D, Q, R, last_Sig, y_t, cur_x){
  
  F_t <- C %*% (A %*% last_Sig %*% t(A) + B %*% Q %*% t(B)) %*% t(A) %*% t(C) + D %*% R %*% t(D)

  e_t <- as.matrix(y_t - C %*% cur_x)

  log_likelihood_t <- -0.5 * (log(det(F_t)) + t(e_t) %*% solve(F_t) %*% e_t + length(y_t) * log(2 * pi))
  return(log_likelihood_t)
}


#get_partial_R(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_R, last_partial_Sig_R, F_t, e_t, A, B, C, D, Q, R)
partial_A_approx <- function(A, B, C, D, Q, R, last_Sig, y_t, cur_x, h=1e-5){
  log_likelihood_0 <- KF_likelihood(A, B, C, D, Q, R, last_Sig, y_t, cur_x)
  
  grad_A <- matrix(0, nrow=nrow(A), ncol=ncol(A))
  
  for (i in 1:nrow(A)) {
    for (j in 1:ncol(A)) {
      # Create perturbed matrices
      A_plus <- A
      A_minus <- A
      
      A_plus[i, j] <- A_plus[i, j] + h
      A_minus[i, j] <- A_minus[i, j] - h

      log_likelihood_plus <- KF_likelihood(A_plus, B, C, D, Q, R, last_Sig, y_t, cur_x)
      log_likelihood_minus <- KF_likelihood(A_minus, B, C, D, Q, R, last_Sig, y_t, cur_x)

      grad_A[i, j] <- (log_likelihood_plus - log_likelihood_minus) / (2 * h)
    }
  }
  return(grad_A)
}

A <- diag(3) # 3 * 3
B <- diag(3) # 3 * 3
C <- get_C(lambda, tenors = tenors) #  nelson siegel design matrix
D <- diag(N) # N * N
Q <- diag(3) # 3 * 3
R <- diag(N) # N * N
cur_x <- matrix(1, ncol = 1, nrow = 3)
last_Sig <- diag(3)

partial_A_approx(A, B, C, D, Q, R, last_Sig = last_Sig, y_t = synthetic_OLS_yields_Long_R[[3]][2], cur_x = cur_x, h=1e-2)

```

```{r}
numerical_gradient_loglik <- function(kalman_func, param_name, param_matrix, Y, A, B, C, D, Q, R, x0, Sigma0, h=1e-5) {
  # Get current log-likelihood
  log_likelihood_0 <- kalman_func(Y, A, B, C, D, Q, R, x0, Sigma0)$log_likelihood
  
  grad_matrix <- matrix(0, nrow=nrow(param_matrix), ncol=ncol(param_matrix))
  
  for (i in 1:nrow(param_matrix)) {
    for (j in 1:ncol(param_matrix)) {
      # Create perturbed matrices
      param_plus <- param_matrix
      param_minus <- param_matrix
      
      param_plus[i, j] <- param_plus[i, j] + h
      param_minus[i, j] <- param_minus[i, j] - h
      
      # Compute perturbed log-likelihood
      log_likelihood_plus <- switch(param_name,
        "A" = kalman_func(Y, param_plus, B, C, D, Q, R, x0, Sigma0)$log_likelihood,
        "B" = kalman_func(Y, A, param_plus, C, D, Q, R, x0, Sigma0)$log_likelihood,
        "C" = kalman_func(Y, A, B, param_plus, D, Q, R, x0, Sigma0)$log_likelihood,
        "D" = kalman_func(Y, A, B, C, param_plus, Q, R, x0, Sigma0)$log_likelihood,
        "Q" = kalman_func(Y, A, B, C, D, param_plus, R, x0, Sigma0)$log_likelihood,
        "R" = kalman_func(Y, A, B, C, D, Q, param_plus, x0, Sigma0)$log_likelihood
      )
      
      log_likelihood_minus <- switch(param_name,
        "A" = kalman_func(Y, param_minus, B, C, D, Q, R, x0, Sigma0)$log_likelihood,
        "B" = kalman_func(Y, A, param_minus, C, D, Q, R, x0, Sigma0)$log_likelihood,
        "C" = kalman_func(Y, A, B, param_minus, D, Q, R, x0, Sigma0)$log_likelihood,
        "D" = kalman_func(Y, A, B, C, param_minus, Q, R, x0, Sigma0)$log_likelihood,
        "Q" = kalman_func(Y, A, B, C, D, param_minus, R, x0, Sigma0)$log_likelihood,
        "R" = kalman_func(Y, A, B, C, D, Q, param_minus, x0, Sigma0)$log_likelihood
      )
      
      # Compute gradient using midpoint approximation
      grad_matrix[i, j] <- (log_likelihood_plus - log_likelihood_minus) / (2 * h)
    }
  }
  
  return(grad_matrix)
}

```


# KF test ( may not work beacsue of the bias from matrix inversion)
```{r}

KF_Estimate(yields, 10, tenors = c(1/12,3/12,6/12,1,2,3,5,7,10,20), lambda = 0.5)
KF_Estimate(synthetic_OLS_yields_Long_R, 960, tenors = c(1/12,3/12,6/12,1,2,3,5,7,10,20), lambda = 0.5)
KF_Estimate(yields = last960FredYields, 960, tenors = c(1/12,3/12,6/12,1,2,3,5,7,10,20,30), lambda = 0.5)

```


# case studies (not finished)
```{r}
set.seed(123)
beta <- c(5, -3, 3)

A_stable <- matrix(c(0.7, 0.3, -0.2,
                     -0.2, 0.8, 0.1,
                      0.1, -0.1, 0.7), nrow = 3, byrow = TRUE)



T_ <- 200

beta_values <- matrix(0, nrow = T_, ncol = 3)

beta_values[1, ] <- beta

for (t in 2:T_) {
  beta_values[t, ] <- A %*% beta_values[t - 1, ]
}

data <- list()
for( i in 1:20){
  data[[i]] <- generate_data(T_ = 1, betas = beta_values[i, ], lambda = 0.5, GLS = F)$yield_list[[1]]
  
}
data[[1]]
data[[1]][1]
KF_Estimate(data, 20, tenors = c(1/12,3/12,6/12,1,2,3,5,7,10,20), lambda = 0.5, x_init = c(5, -3, 3))


Q <- matrix()
10 * log10( det(1.1 * R) / det( Q) )

KF_Estimate(yields, T_, tenors = c(1/12,3/12,6/12,1,2,3,5,7,10,20), lambda = 0.5, x_init = c(5, -3, 3))
```



```{r}
# Case study on the initialization of paratmeters


```

```{r}
# Case study on the 
```

```{r}

KF_Estimate_gneral <- function(y_data , T_, dim_A = a, dim_cov_R = r, dim_cov_Q = q){
    # y_data: Parameter of the form of a list of data frames 
    # T_: length of time window
    # x: a * 1
    # y: k * 1
    
    k <- ncol(y) # dimension of y at time t
    
    # Initialization of parameters 
    # In the early stage, we assume default dimension for Q and R, B hence D to be 3*3/n*n identity matrix 
    A <- diag(a) # a * a
    B <- matrix(rnorm(a * r), nrow = a, ncol = r)  # a * r # a * r 
    Q <- diag(r) # r * r
    C <- matrix(rnorm(k * a), nrow = k, ncol = a) # k * a
    D <- matrix(rnorm(k * q), nrow = k, ncol = q) # k * q
    R <- diag(q) # q * q
    
    
    # place holder for last result iteration of parameter estimation
    lastA <- 10*diag(a) # a * a
    lastB <- 10*matrix(rnorm(a * r), nrow = a, ncol = r)  # a * r # a * r 
    lastQ <- 10*diag(r) # r * r
    lastC <- 10*matrix(rnorm(k * a), nrow = k, ncol = a) # k * a
    lsatD <- 10*matrix(rnorm(k * q), nrow = k, ncol = q) # k * q
    lastR <- 10*diag(q) # q * q
    
    # Initialization of partial derivatives w.r.t paramters
    partial_log_l_A <- diag(a) # a * a
    partial_log_l_B <- matrix(rnorm(a * r), nrow = a, ncol = r)  # a * r # a * r 
    partial_log_l_Q <- diag(r) # r * r
    partial_log_l_C <- matrix(rnorm(k * a), nrow = k, ncol = a) # k * a
    partial_log_l_D <- matrix(rnorm(k * q), nrow = k, ncol = q) # k * q
    partial_log_l_R <- diag(q) # q * q
    
    
    num_run <- 0
    
    
    repeat{
        # Initilaiation of paramters
        
        last_x <- matrix( 1, ncol =1, nrow = a) # x_{0|0}
        last_Sig <- diag(3) #Sigma_{0|0}
        
        # Initilization of partial derivatives at time 0|0
        # expand the matrix partial derivative into a vector with a length equal to the number of its entries.
        last_partial_x_A <-  lapply(1:(a^2), function(x) matrix(1, nrow = a, ncol = 1)) # a^2 * (a * 1)
        last_partial_Sig_A <-  lapply(1:(a^2), function(x) diag(a)) # a^2 * (a * a)
        
        last_partial_x_B <-  lapply(1:(a*q), function(x) matrix(1, nrow = a, ncol = 1)) # a*q * (1 * a)
        last_partial_Sig_B <-  lapply(1:(a*q), function(x) diag(a)) # 9 * (a * a)
        
        last_partial_x_Q <-  lapply(1:(q*q), function(x) matrix(1, nrow = a, ncol = 1)) # q*q * (1 * a)
        last_partial_Sig_Q <-  lapply(1:(q*q), function(x) diag(a)) # q*q * (a * a)
        
        last_partial_x_C <-  lapply(1:(k*a), function(x) matrix(1, nrow = a, ncol = 1)) # k*a * (1 * a)
        last_partial_Sig_C <-  lapply(1:(k*a), function(x) diag(a)) # k*a * (a * a)
        
        last_partial_x_D <-  lapply(1:(k*r), function(x) matrix(1, nrow = a, ncol = 1)) # k*r * (1 * a)
        last_partial_Sig_D <-  lapply(1:(k*r), function(x) diag(a)) # k*r * (a * a)
        
        last_partial_x_R <-  lapply(1:(r*r), function(x) matrix(1, nrow = 3, ncol = 1)) # r*r * (1 * a)
        last_partial_Sig_R <-  lapply(1:(r*r), function(x) diag(a)) # r*r * (a * a)
        
        # list of y_data rate data (T_ * (N * 2))
        

        # iterate along time 1:T_
        for(i in 1:nrow(y_data)){  
          
            pred_res <- FK_prediction(A, B, C, D, R, Q, last_x, last_Sig) # one step ahead prediction of x and y
            
            cur_x      <- pred_res$E_x_t
            cur_Sig  <- pred_res$Var_x_t
            cur_y           <- pred_res$E_y_t
            F_t         <- pred_res$Var_y_t
            
            K_t <- cur_Sig %*% t(C) %*% ginv(F_t) # Kalman Gain a * k
            e_t <- y_data[i,] - C %*% cur_x # innovation k * 1
            
            # state estimate update
            next_x <- cur_x + K_t %*% (y_data[i,] - C %*% cur_x) # x_{t|t}
            next_Sig <- cur_Sig - K_t %*% C %*% cur_Sig # Sigma_{t|t}
                
            # calcualte the partial derivatives w.r.t. each paramter
            partial_A_res <- get_partial_A(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_A, last_partial_Sig_A, F_t, e_t, A, B, C, D, Q, R)
            partial_B_res <- get_partial_B(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_B, last_partial_Sig_B, F_t, e_t, A, B, C, D, Q, R)
            partial_Q_res <- get_partial_Q(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_Q, last_partial_Sig_Q, F_t, e_t, A, B, C, D, Q, R)
            partial_C_res <- get_partial_C(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_C, last_partial_Sig_C, F_t, e_t, A, B, C, D, Q, R)
            partial_D_res <- get_partial_D(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_D, last_partial_Sig_D, F_t, e_t, A, B, C, D, Q, R)
            partial_R_res <- get_partial_R(last_x, last_Sig, cur_x, cur_Sig, last_partial_x_R, last_partial_Sig_R, F_t, e_t, A, B, C, D, Q, R)
            
            # convert the partial derivative from entry by entry form into matrix form
            partial_log_A_t <- matrix(partial_A_res$log_likelihood_A, nrow = a, ncol = a, byrow = TRUE)  
            partial_log_B_t <- matrix(partial_B_res$log_likelihood_B, nrow = a, ncol = q, byrow = TRUE) 
            partial_log_Q_t <- matrix(partial_Q_res$log_likelihood_Q, nrow = q, ncol = q, byrow = TRUE) 
            partial_log_C_t <- matrix(partial_C_res$log_likelihood_C, nrow = k, ncol = a, byrow = TRUE) 
            partial_log_D_t <- matrix(partial_D_res$log_likelihood_D, nrow = k, ncol = r, byrow = TRUE) 
            partial_log_R_t <- matrix(partial_R_res$log_likelihood_R, nrow = r, ncol = r, byrow = TRUE) 

            
            # add the current time partial_log_likelihood to the summation of partial_log_likelihood over time 1:T_
            partial_log_l_A <- partial_log_l_A + partial_log_A_t
            partial_log_l_B <- partial_log_l_B + partial_log_A_t
            partial_log_l_Q <- partial_log_l_Q + partial_log_Q_t
            partial_log_l_C <- partial_log_l_C + partial_log_A_t
            partial_log_l_D <- partial_log_l_D + partial_log_A_t
            partial_log_l_R <- partial_log_l_R + partial_log_R_t
          
            # update for the next state ( in the format of linked list)
            last_partial_x_A <- partial_A_res$next_partial_x_A
            last_partial_Sig_A <- partial_A_res$next_partial_Sig_A
            
            last_partial_x_Q <- partial_Q_res$next_partial_x_Q
            last_partial_Sig_Q <- partial_Q_res$next_partial_Sig_Q
            
            last_partial_x_R <- partial_R_res$next_partial_x_R
            last_partial_Sig_R <- partial_R_res$next_partial_Sig_R
            
            last_x <- next_x # x_{t|t}
            last_Sig <- next_Sig  # Sigma_{t|t}
            
        
        }
  
        # update the 
        A <- A - 0.000001 * partial_log_l_A
        Q <- Q - 0.000001 * partial_log_l_Q
        R <- R - 0.000001 * partial_log_l_R
        
        # Compute the convergece condition by the ratio of difference of paramters, using Euclidean norm
        num <- norm(A - lastA, type = "F") + norm(Q - lastQ, type = "F") + norm(R - lastR, type = "F") # 
        denom <- norm(A, type = "F") + norm(Q, type = "F") + norm(R, type = "F")
        ratio <- num/denom
        #print(ratio)
        
        if(ratio < 0.0001){
          break
        }
        print(F_t)
        # parameter update for the next iteration
        lastA <- A
        lastQ <- Q
        lastR <- R
      

        
        
    }
      
    return(list(A = A, B = B, C = C, D = D, R = R, Q = Q))
  
    
  
    
}
```































